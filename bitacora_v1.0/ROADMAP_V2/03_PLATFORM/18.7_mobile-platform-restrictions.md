```yaml
Archivo: ROADMAP_V2/03_PLATFORM/18.7_mobile-platform-restrictions.md
Versi√≥n: 1.0 - "Android & iOS Platform Restrictions Analysis"
Fecha Creaci√≥n: 2025-11-29
√öltima Actualizaci√≥n: 2025-11-29 23:45:00
Autor: Eduardo GJ + Claude (Copilot)
Prop√≥sito: An√°lisis completo de restricciones Android/iOS y estrategias de mediaci√≥n para Bit√°cora
Estado: RESEARCH & PLANNING - Pre-mobile development
Filosof√≠a: "Conocer las limitaciones antes de dise√±ar. Mediar restricciones, no luchar contra ellas."
Related: 18.6_immune-system-vitality-logs.md (Vigilante daemon), CONFIG_PARAMETERS.md
Tiempo Estimado: 80h mobile adaptation (v4.0+ 2027)
Decisi√≥n Arquitect√≥nica: DA-039 - Mobile Platform Architecture & Restrictions
```

# üì± Mobile Platform Restrictions - Android & iOS

> **Subt√≠tulo**: *"Dise√±ar Bit√°cora para m√≥vil con ojos abiertos. Conocer restricciones, proponer soluciones."*

> **Filosof√≠a**: No luchar contra plataformas. Mediar restricciones creativamente.

---

## üåÖ PRELUDIO: Por Qu√© Este Documento

### El Desaf√≠o M√≥vil

Bit√°cora fue dise√±ada para desktop:

- ‚úÖ Background daemons sin restricci√≥n (Vigilante 24/7)
- ‚úÖ Storage ilimitado (vitality logs, identities, cache)
- ‚úÖ LLM calls sin l√≠mites de battery
- ‚úÖ Procesamiento largo sin interrupci√≥n (importaciones)

**En m√≥vil, TODO esto cambia:**

```
Desktop Bit√°cora          ‚Üí    Mobile Reality
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ
Vigilante daemon 24/7     ‚Üí    15 min max background (iOS)
                               Doze mode kills processes (Android)

Storage ilimitado         ‚Üí    User quota limits
                               App sandboxing (iOS)

LLM calls sin l√≠mites     ‚Üí    Battery drain = user rage
                               Background network restricted

Importaciones largas      ‚Üí    OS kills long-running tasks
                               "App Not Responding" dialogs
```

**Eduardo sabiamente dice:**

> "Necesitamos analizar todas las posibles restricciones de Android y Apple 
> y c√≥mo podr√≠amos mediarlas."

**Este documento es esa an√°lisis.** üîç

---

## ü§ñ PARTE 1: ANDROID RESTRICTIONS

### 1.1 Background Execution

#### Restricci√≥n: Doze Mode & App Standby

**Problema:**

```
Android 6.0+ (Marshmallow):
- Doze Mode: Device idle ‚Üí apps "standby"
  * Network access denied
  * Wakelocks ignored
  * AlarmManager deferred
  * JobScheduler delayed

- App Standby: Per-app buckets
  * Active: Normal behavior
  * Working Set: Deferred jobs (2h delay)
  * Frequent: Jobs run 1x/day
  * Rare: Jobs run 1x/week
  * Restricted: Extreme limits
```

**Impacto en Bit√°cora:**

- ‚ùå **Vigilante daemon**: No puede monitorear 24/7
- ‚ùå **VitalityLog writer**: Checks cada 5 min ‚Üí 1x/d√≠a
- ‚ùå **Bit√°coraCorp sync**: Delayed hours

#### Mediaci√≥n: Foreground Services + WorkManager

**Estrategia:**

```kotlin
// Foreground Service para procesos largos
class BitacoraImportService : Service() {
    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {
        // Show persistent notification (required)
        val notification = NotificationCompat.Builder(this, CHANNEL_ID)
            .setContentTitle("Bit√°cora importando WhatsApp")
            .setContentText("406 im√°genes analizando...")
            .setSmallIcon(R.drawable.ic_bitacora)
            .setProgress(100, 0, false)
            .build()
        
        startForeground(NOTIFICATION_ID, notification)
        
        // Long-running import protected from Doze
        lifecycleScope.launch {
            whatsappDigester.importConversation()
        }
        
        return START_NOT_STICKY
    }
}

// WorkManager para tareas peri√≥dicas
class VigilanteHealthCheckWorker(context: Context, params: WorkerParameters) 
    : CoroutineWorker(context, params) {
    
    override suspend fun doWork(): Result {
        // Health check (survives Doze)
        val vigilante = Vigilante.getInstance()
        vigilante.healthCheck()
        
        return Result.success()
    }
}

// Schedule periodic health checks
val healthCheckRequest = PeriodicWorkRequestBuilder<VigilanteHealthCheckWorker>(
    15, TimeUnit.MINUTES // Minimum allowed
).setConstraints(
    Constraints.Builder()
        .setRequiredNetworkType(NetworkType.CONNECTED)
        .setRequiresBatteryNotLow(true)
        .build()
).build()

WorkManager.getInstance(context).enqueue(healthCheckRequest)
```

**Trade-offs:**

- ‚úÖ Import protegido con Foreground Service
- ‚úÖ Vigilante checks cada 15 min (vs 5 min desktop)
- ‚ö†Ô∏è Notification visible (Android requirement)
- ‚ùå No monitoreo en tiempo real durante Doze

---

### 1.2 Storage Restrictions

#### Restricci√≥n: Scoped Storage (Android 10+)

**Problema:**

```
Android 10+ (Q):
- Apps solo acceden su directorio privado
  * /data/data/com.bitacora/
  * No acceso directo a /storage/emulated/0/

- MediaStore API requerida para multimedia
  * Permisos READ_EXTERNAL_STORAGE
  * Cada archivo requiere URI permission

- SAF (Storage Access Framework)
  * User selecciona carpetas expl√≠citamente
  * App obtiene persistable URI permissions
```

**Impacto en Bit√°cora:**

- ‚ùå **WhatsApp import**: No acceso directo a `/WhatsApp/Media/`
- ‚ùå **Identity photos**: Requiere MediaStore queries
- ‚ö†Ô∏è **Vitality logs**: Solo en app-private dir

#### Mediaci√≥n: SAF + MediaStore Hybrid

**Estrategia:**

```kotlin
// SAF: User selecciona carpeta WhatsApp
fun requestWhatsAppFolderAccess(): Uri? {
    val intent = Intent(Intent.ACTION_OPEN_DOCUMENT_TREE).apply {
        putExtra(DocumentsContract.EXTRA_INITIAL_URI, 
            MediaStore.Files.getContentUri("external"))
    }
    
    startActivityForResult(intent, REQUEST_WHATSAPP_FOLDER)
    
    // User selecciona /WhatsApp/Media/ manualmente
    // App guarda persistable permission
}

override fun onActivityResult(requestCode: Int, resultCode: Int, data: Intent?) {
    if (requestCode == REQUEST_WHATSAPP_FOLDER && resultCode == RESULT_OK) {
        data?.data?.let { treeUri ->
            // Persistable access
            contentResolver.takePersistableUriPermission(
                treeUri,
                Intent.FLAG_GRANT_READ_URI_PERMISSION
            )
            
            // Save for future imports
            prefs.edit().putString("whatsapp_folder_uri", treeUri.toString()).apply()
            
            // Start import
            whatsappDigester.importFrom(treeUri)
        }
    }
}

// MediaStore: Query identities photos
fun getAllPhotosWithFaces(): List<PhotoUri> {
    val projection = arrayOf(
        MediaStore.Images.Media._ID,
        MediaStore.Images.Media.DISPLAY_NAME,
        MediaStore.Images.Media.DATE_TAKEN
    )
    
    val cursor = contentResolver.query(
        MediaStore.Images.Media.EXTERNAL_CONTENT_URI,
        projection,
        null, null,
        "${MediaStore.Images.Media.DATE_TAKEN} DESC"
    )
    
    return cursor?.use {
        // Process photos with Vision LLM
        generateSequence { if (it.moveToNext()) it else null }
            .map { /* convert to PhotoUri */ }
            .toList()
    } ?: emptyList()
}
```

**Trade-offs:**

- ‚úÖ User controla permisos expl√≠citamente (privacy-first)
- ‚úÖ Persistable access a carpetas seleccionadas
- ‚ö†Ô∏è UX friction (user debe seleccionar carpeta cada app install)
- ‚ùå No acceso autom√°tico a archivos (deliberado)

---

### 1.3 Battery & Performance

#### Restricci√≥n: Battery Optimization

**Problema:**

```
Android 6.0+ Battery Optimization:
- Background limits:
  * CPU throttling
  * Network access restricted
  * Location updates stopped
  
- User can disable optimization per-app
  * Settings ‚Üí Battery ‚Üí Battery Optimization
  * REQUEST_IGNORE_BATTERY_OPTIMIZATIONS permission
  * Google Play restricts this permission (approval required)
```

**Impacto en Bit√°cora:**

- ‚ùå **Vision LLM analysis**: Slow en background
- ‚ùå **Identity matching**: Deferred
- ‚ö†Ô∏è **LLM costs**: User preocupado por battery drain

#### Mediaci√≥n: Smart Scheduling + User Control

**Estrategia:**

```kotlin
// Detect charging state
fun scheduleHeavyWork() {
    val constraints = Constraints.Builder()
        .setRequiresCharging(true)  // Only when charging
        .setRequiresBatteryNotLow(true)
        .setRequiredNetworkType(NetworkType.UNMETERED) // Wi-Fi only
        .build()
    
    val visionAnalysisRequest = OneTimeWorkRequestBuilder<VisionLLMWorker>()
        .setConstraints(constraints)
        .build()
    
    WorkManager.getInstance(context).enqueue(visionAnalysisRequest)
}

// User control: Config parameters
sealed class AnalysisMode {
    object Aggressive : AnalysisMode() // Any time
    object Balanced : AnalysisMode()   // Charging + Wi-Fi
    object Conservative : AnalysisMode() // Manual only
}

// Battery-aware LLM client
class BatteryAwareLLMClient(private val batteryManager: BatteryManager) {
    suspend fun analyzeImage(image: ByteArray): ImageAnalysis {
        val batteryPct = batteryManager.getIntProperty(
            BatteryManager.BATTERY_PROPERTY_CAPACITY
        )
        
        return when {
            batteryPct < 20 -> {
                // Skip Vision LLM, use cached analysis or defer
                ImageAnalysis.deferred("Low battery")
            }
            batteryPct < 50 && !isCharging() -> {
                // Use lightweight local model
                localImageAnalyzer.analyze(image)
            }
            else -> {
                // Full Vision LLM analysis
                visionLLMClient.analyze(image)
            }
        }
    }
}
```

**Trade-offs:**

- ‚úÖ Respeta battery del usuario
- ‚úÖ Heavy work solo cuando charging
- ‚ö†Ô∏è An√°lisis deferred (menos real-time)
- ‚úÖ User configurable (CONFIG_PARAMETERS.md)

---

### 1.4 Permissions Model

#### Restricci√≥n: Runtime Permissions (Android 6.0+)

**Problema:**

```
Dangerous Permissions (require user approval):
- CAMERA: Photo capture
- READ_EXTERNAL_STORAGE: Access photos
- WRITE_EXTERNAL_STORAGE: Save exports
- READ_CONTACTS: Identity suggestions (future)
- RECORD_AUDIO: Voice transcription

User can:
- Deny permission ‚Üí App feature broken
- Grant "While using app" only (not background)
- Revoke permission anytime
```

**Impacto en Bit√°cora:**

- ‚ùå **Identity photos**: Requiere READ_EXTERNAL_STORAGE
- ‚ùå **WhatsApp import**: Requiere file access
- ‚ö†Ô∏è **Voice transcription**: RECORD_AUDIO scary for users

#### Mediaci√≥n: Graceful Degradation + Transparent Requests

**Estrategia:**

```kotlin
// Permission request con contexto expl√≠cito
class PermissionExplainer(private val activity: Activity) {
    fun requestStorageAccess(reason: String, onGranted: () -> Unit) {
        // Show explanation BEFORE requesting
        AlertDialog.Builder(activity)
            .setTitle("¬øPor qu√© necesito acceso a fotos? üîí")
            .setMessage("""
                Bit√°cora necesita leer tus fotos para:
                ‚Ä¢ Analizar im√°genes en conversaciones WhatsApp
                ‚Ä¢ Identificar personas con tu consentimiento
                ‚Ä¢ Crear "pixeles biogr√°ficos"
                
                Tu privacidad:
                ‚úÖ Fotos nunca salen de tu dispositivo
                ‚úÖ Vision LLM solo analiza con tu aprobaci√≥n
                ‚úÖ Puedes revocar acceso en cualquier momento
            """.trimIndent())
            .setPositiveButton("Entiendo, conceder acceso") { _, _ ->
                ActivityCompat.requestPermissions(
                    activity,
                    arrayOf(Manifest.permission.READ_EXTERNAL_STORAGE),
                    REQUEST_STORAGE
                )
            }
            .setNegativeButton("No ahora") { dialog, _ ->
                dialog.dismiss()
                // Feature disabled gracefully
            }
            .show()
    }
    
    override fun onRequestPermissionsResult(
        requestCode: Int,
        permissions: Array<out String>,
        grantResults: IntArray
    ) {
        when (requestCode) {
            REQUEST_STORAGE -> {
                if (grantResults.isNotEmpty() && 
                    grantResults[0] == PackageManager.PERMISSION_GRANTED) {
                    onGranted()
                } else {
                    // Graceful degradation
                    showFeatureLimitedDialog()
                }
            }
        }
    }
}

// Graceful degradation
fun importWhatsApp() {
    when {
        hasStoragePermission() -> {
            // Full import
            whatsappDigester.importConversation()
        }
        else -> {
            // Offer alternatives
            AlertDialog.Builder(context)
                .setTitle("Importaci√≥n limitada")
                .setMessage("""
                    Sin acceso a almacenamiento:
                    
                    Opciones:
                    1. Conceder acceso para import autom√°tico
                    2. Seleccionar archivos manualmente (SAF)
                    3. Exportar conversaci√≥n desde WhatsApp
                """.trimIndent())
                .setPositiveButton("Conceder acceso") { _, _ ->
                    requestStoragePermission()
                }
                .setNeutralButton("Seleccionar manualmente") { _, _ ->
                    openDocumentPicker()
                }
                .show()
        }
    }
}
```

**Trade-offs:**

- ‚úÖ Transparencia total (usuario sabe por qu√©)
- ‚úÖ Graceful degradation (no crashes)
- ‚ö†Ô∏è UX friction si usuario niega
- ‚úÖ Trust building (explicaciones claras)

---

### 1.5 Google Play Store Policies

#### Restricci√≥n: Play Store Review Guidelines

**Problemas:**

```
Restricted Permissions (require approval):
- REQUEST_IGNORE_BATTERY_OPTIMIZATIONS
  * Must justify "core app functionality"
  * Background monitoring NOT accepted reason
  
- SYSTEM_ALERT_WINDOW
  * Overlay permissions (rejected unless accessibility app)
  
- QUERY_ALL_PACKAGES
  * WhatsApp detection (privacy concern)

Privacy Policy Requirements:
- Disclose ALL data collection
- Explain LLM usage (cloud processing)
- GDPR compliance (EU users)
- Data deletion mechanism
```

**Impacto en Bit√°cora:**

- ‚ùå **Vigilante 24/7**: Battery optimization exemption likely rejected
- ‚ùå **WhatsApp auto-detect**: QUERY_ALL_PACKAGES restricted
- ‚ö†Ô∏è **Vision LLM**: Must disclose cloud API usage in privacy policy
- ‚úÖ **Local-first**: Advantage (minimal data collection)

#### Mediaci√≥n: Privacy-First Design

**Estrategia:**

```kotlin
// Privacy Policy disclosures
"""
BIT√ÅCORA PRIVACY POLICY

Data Collection:
‚úÖ Photos: Analyzed locally or with explicit consent
‚úÖ Identity data: Stored ONLY on device (YAML files)
‚úÖ Vision LLM: OpenAI GPT-4o Vision API (opt-in)
  ‚Ä¢ Images sent to OpenAI for analysis
  ‚Ä¢ No PII in requests (only image bytes)
  ‚Ä¢ Responses cached locally (no cloud storage)

Data NOT Collected:
‚ùå Contacts
‚ùå Location
‚ùå Personal messages (only metadata)
‚ùå Biometric data (no face embeddings until v1.5)

User Rights:
‚úÖ Delete ALL data: Settings ‚Üí Delete All Data
‚úÖ Revoke LLM access: Settings ‚Üí Disable Vision Analysis
‚úÖ Export data: YAML files accessible via SAF
‚úÖ Opt-out telemetry: Settings ‚Üí Privacy ‚Üí Telemetry (default: OFF)

Third-Party Services:
- OpenAI GPT-4o Vision (opt-in, for image analysis)
  Privacy: https://openai.com/privacy
- Bit√°cora Corp (opt-in, for updates only)
  Privacy: No PII transmitted, anonymous health stats

GDPR Compliance:
‚úÖ Right to access: Export YAML files
‚úÖ Right to deletion: Delete All Data button
‚úÖ Right to portability: YAML/JSON export
‚úÖ Right to restriction: Disable features granularly
"""

// Play Store listing
"""
Bit√°cora - Your Personal Memory Organism

Privacy-First Features:
‚Ä¢ 100% local-first (identities never leave device)
‚Ä¢ Optional cloud LLM (explicit consent required)
‚Ä¢ No ads, no tracking, no data selling
‚Ä¢ Open source (GitHub: bitacora-ai/bitacora)

Permissions Explained:
‚Ä¢ Storage: Import WhatsApp conversations
‚Ä¢ Camera: Capture biographical moments
‚Ä¢ Audio: Voice transcription (future feature)

All permissions optional, features work without them.
"""
```

**Trade-offs:**

- ‚úÖ Transparent privacy practices
- ‚úÖ Play Store approval likely
- ‚ö†Ô∏è No background monitoring exemption
- ‚úÖ User trust maximized

---

## üçé PARTE 2: iOS RESTRICTIONS

### 2.1 Background Execution

#### Restricci√≥n: Background App Refresh

**Problema:**

```
iOS Background Modes:
- Background App Refresh: 15 minutes max
  * System decides WHEN to wake app
  * No guarantees (battery, network, user settings)
  
- Background Tasks (iOS 13+):
  * BGAppRefreshTask: ~15 min intervals
  * BGProcessingTask: Long tasks when charging
  * Not guaranteed execution
  
- Background Modes (special cases):
  * Audio: Continuous playback
  * Location: GPS tracking
  * VoIP: Push notifications
  * None applicable to Bit√°cora
```

**Impacto en Bit√°cora:**

- ‚ùå **Vigilante daemon**: Impossible 24/7 monitoring
- ‚ùå **VitalityLog writer**: Unreliable scheduling
- ‚ùå **Bit√°coraCorp sync**: Delayed hours/days

#### Mediaci√≥n: On-Demand + BGProcessingTask

**Estrategia:**

```swift
// BGAppRefreshTask para health checks
func scheduleHealthCheck() {
    let request = BGAppRefreshTaskRequest(identifier: "com.bitacora.healthcheck")
    request.earliestBeginDate = Date(timeIntervalSinceNow: 15 * 60) // 15 min
    
    do {
        try BGTaskScheduler.shared.submit(request)
    } catch {
        print("Could not schedule health check: \(error)")
    }
}

extension AppDelegate {
    func application(_ application: UIApplication,
                    didFinishLaunchingWithOptions launchOptions: [UIApplication.LaunchOptionsKey: Any]?) -> Bool {
        
        // Register background tasks
        BGTaskScheduler.shared.register(
            forTaskWithIdentifier: "com.bitacora.healthcheck",
            using: nil
        ) { task in
            self.handleHealthCheck(task: task as! BGAppRefreshTask)
        }
        
        return true
    }
    
    func handleHealthCheck(task: BGAppRefreshTask) {
        // Schedule next run
        scheduleHealthCheck()
        
        // Perform health check
        let vigilante = Vigilante.shared
        
        task.expirationHandler = {
            // iOS is about to kill task
            vigilante.cancel()
        }
        
        vigilante.performHealthCheck { success in
            task.setTaskCompleted(success: success)
        }
    }
}

// BGProcessingTask para long-running imports (charging only)
func scheduleWhatsAppImport() {
    let request = BGProcessingTaskRequest(identifier: "com.bitacora.import")
    request.requiresNetworkConnectivity = true
    request.requiresExternalPower = true // Charging only
    
    do {
        try BGTaskScheduler.shared.submit(request)
    } catch {
        print("Could not schedule import: \(error)")
    }
}
```

**Trade-offs:**

- ‚úÖ Health checks cada ~15 min (cuando iOS decide)
- ‚úÖ Long imports solo cuando charging
- ‚ùå No garant√≠a de ejecuci√≥n (iOS controla)
- ‚ö†Ô∏è User puede desactivar Background App Refresh

---

### 2.2 Storage & Sandboxing

#### Restricci√≥n: App Sandbox

**Problema:**

```
iOS App Sandbox:
- App container:
  * Documents/: User-generated content
  * Library/: App support files
  * tmp/: Temporary files (cleared by system)
  
- NO acceso a:
  * Filesystem global
  * Otros app containers
  * Photos library (sin permission)
  * Files app (sin document picker)

- Photo Library:
  * PHPhotoLibrary API (permission required)
  * Limited Photos (iOS 14+): User selects specific photos
  * No bulk access to all photos
```

**Impacto en Bit√°cora:**

- ‚ùå **WhatsApp import**: No acceso directo a WhatsApp files
- ‚ö†Ô∏è **Identity photos**: Limited Photos selection
- ‚úÖ **Vitality logs**: Safe in Documents/

#### Mediaci√≥n: Document Picker + PHPicker

**Estrategia:**

```swift
// Document Picker para WhatsApp export
import UniformTypeIdentifiers

class WhatsAppImporter: UIViewController, UIDocumentPickerDelegate {
    func selectWhatsAppExport() {
        let picker = UIDocumentPickerViewController(
            forOpeningContentTypes: [UTType.zip, UTType.folder],
            asCopy: true
        )
        picker.delegate = self
        picker.allowsMultipleSelection = false
        
        present(picker, animated: true)
    }
    
    func documentPicker(_ controller: UIDocumentPickerViewController,
                       didPickDocumentsAt urls: [URL]) {
        guard let url = urls.first else { return }
        
        // User selected WhatsApp export zip
        whatsappDigester.importFromZip(url)
    }
}

// PHPicker para identity photos
import PhotosUI

class IdentityPhotoSelector: UIViewController, PHPickerViewControllerDelegate {
    func selectIdentityPhotos() {
        var config = PHPickerConfiguration(photoLibrary: .shared())
        config.selectionLimit = 0 // Unlimited
        config.filter = .images
        
        let picker = PHPickerViewController(configuration: config)
        picker.delegate = self
        
        present(picker, animated: true)
    }
    
    func picker(_ picker: PHPickerViewController,
               didFinishPicking results: [PHPickerResult]) {
        picker.dismiss(animated: true)
        
        for result in results {
            result.itemProvider.loadObject(ofClass: UIImage.self) { image, error in
                if let image = image as? UIImage {
                    // Process image with Vision LLM
                    self.processIdentityPhoto(image)
                }
            }
        }
    }
}

// Limited Photos workflow (iOS 14+)
import Photos

func requestPhotoLibraryAccess() {
    PHPhotoLibrary.requestAuthorization { status in
        switch status {
        case .authorized:
            // Full access (rare)
            self.importAllPhotos()
            
        case .limited:
            // User selected specific photos
            self.showLimitedPhotosExplanation()
            
        case .denied, .restricted:
            // No access
            self.showManualSelectionOption()
            
        @unknown default:
            break
        }
    }
}
```

**Trade-offs:**

- ‚úÖ Privacy-preserving (user selects files)
- ‚ö†Ô∏è UX friction (manual selection)
- ‚ùå No automatic WhatsApp detection
- ‚úÖ Limited Photos preferred by iOS

---

### 2.3 Battery & Performance

#### Restricci√≥n: Energy Impact

**Problema:**

```
iOS Energy Monitoring:
- Settings ‚Üí Battery ‚Üí Battery Usage by App
  * Users see which apps drain battery
  * "Background Activity" shown separately
  
- High energy usage:
  * Negative reviews
  * User disables Background App Refresh
  * iOS may throttle app automatically
  
- Network activity:
  * Cellular data shown per-app
  * Users angry if unexpectedly high
```

**Impacto en Bit√°cora:**

- ‚ö†Ô∏è **Vision LLM**: High energy (API calls)
- ‚ö†Ô∏è **Image analysis**: CPU-intensive
- ‚ùå **Background processing**: Drains battery

#### Mediaci√≥n: Energy-Conscious Design

**Estrategia:**

```swift
// Energy-aware LLM client
class EnergyAwareLLMClient {
    private let processInfo = ProcessInfo.processInfo
    
    func analyzeImage(_ image: UIImage) async throws -> ImageAnalysis {
        // Check power state
        let isPluggedIn = processInfo.isLowPowerModeEnabled == false &&
                         UIDevice.current.batteryState == .charging
        
        let batteryLevel = UIDevice.current.batteryLevel
        
        switch (isPluggedIn, batteryLevel) {
        case (true, _):
            // Charging: Full Vision LLM
            return try await visionLLMClient.analyze(image)
            
        case (false, 0.5...):
            // >50% battery: Balanced mode
            if await cacheHit(for: image) {
                return getCached(image)
            } else {
                return try await visionLLMClient.analyze(image)
            }
            
        case (false, 0.2..<0.5):
            // 20-50% battery: Conservative
            return getCached(image) ?? .defer
            
        default:
            // <20% battery: Skip analysis
            return .defer
        }
    }
}

// Low Power Mode detection
extension Notification.Name {
    static let lowPowerModeChanged = Notification.Name.NSProcessInfoPowerStateDidChange
}

class BitacoraApp {
    init() {
        NotificationCenter.default.addObserver(
            self,
            selector: #selector(powerStateChanged),
            name: .lowPowerModeChanged,
            object: nil
        )
    }
    
    @objc func powerStateChanged() {
        let lowPowerMode = ProcessInfo.processInfo.isLowPowerModeEnabled
        
        if lowPowerMode {
            // Pause non-essential tasks
            vigilante.pause()
            llmClient.enterLowPowerMode()
            
            // Show user notification
            showNotification("Bit√°cora en modo ahorro de energ√≠a ‚ö°")
        } else {
            vigilante.resume()
            llmClient.exitLowPowerMode()
        }
    }
}

// Network awareness (Wi-Fi only by default)
import Network

class NetworkAwareLLMClient {
    private let monitor = NWPathMonitor()
    private var isOnWiFi = false
    
    init() {
        monitor.pathUpdateHandler = { path in
            self.isOnWiFi = path.usesInterfaceType(.wifi)
        }
        monitor.start(queue: DispatchQueue.global())
    }
    
    func analyzeImage(_ image: UIImage) async throws -> ImageAnalysis {
        guard isOnWiFi || userAllowsCellular else {
            // Defer until Wi-Fi available
            return .defer
        }
        
        return try await visionLLMClient.analyze(image)
    }
}
```

**Trade-offs:**

- ‚úÖ Respeta battery del usuario
- ‚úÖ Auto-adapta a power state
- ‚ö†Ô∏è An√°lisis deferred cuando low battery
- ‚úÖ Wi-Fi only por default (configurable)

---

### 2.4 Permissions Model

#### Restricci√≥n: Privacy Nutrition Labels (App Store)

**Problema:**

```
iOS 14+ Privacy Labels (REQUIRED):
- Data Used to Track You:
  * Cross-app tracking
  * Advertising identifiers
  
- Data Linked to You:
  * Name, email, photos
  * Identifiers
  
- Data Not Linked to You:
  * Anonymous analytics
  
Users see BEFORE downloading app.
Misleading labels = App Store rejection.
```

**Impacto en Bit√°cora:**

- ‚ö†Ô∏è **Vision LLM**: "Photos" ‚Üí Data Linked to You
- ‚ö†Ô∏è **Identity data**: Must disclose
- ‚úÖ **Local-first**: Advantage (minimal labels)

#### Mediaci√≥n: Minimal Data Collection

**Estrategia:**

```swift
// App Store Privacy Label (ejemplo Bit√°cora)
"""
Privacy Nutrition Label:

DATA USED TO TRACK YOU:
‚ùå None

DATA LINKED TO YOU:
‚Ä¢ Photos (with explicit consent, for image analysis)
  Usage: Identify people in your photos
  Optional: Can use app without this feature

DATA NOT LINKED TO YOU:
‚Ä¢ Crash Data (anonymous, opt-in)
‚Ä¢ Performance Data (anonymous, opt-in)

Third-Party Services:
‚Ä¢ OpenAI GPT-4o Vision (opt-in for image analysis)
  Data sent: Images only
  Data stored: None (responses cached locally)
"""

// Runtime permission request
import Photos

class PhotoPermissionExplainer {
    func requestPhotoAccess() {
        // Show pre-permission explanation
        let alert = UIAlertController(
            title: "üîí Acceso a Fotos",
            message: """
            Bit√°cora necesita acceso para:
            ‚Ä¢ Analizar im√°genes en conversaciones
            ‚Ä¢ Identificar personas (con tu consentimiento)
            
            Tu privacidad:
            ‚úÖ Fotos procesadas localmente
            ‚úÖ Vision LLM solo si apruebas
            ‚úÖ Datos nunca salen de tu dispositivo
            ‚úÖ Puedes usar "Select Photos" (iOS 14+)
            """,
            preferredStyle: .alert
        )
        
        alert.addAction(UIAlertAction(title: "Permitir Acceso", style: .default) { _ in
            PHPhotoLibrary.requestAuthorization(for: .readWrite) { status in
                // Handle authorization
            }
        })
        
        alert.addAction(UIAlertAction(title: "Seleccionar Fotos", style: .default) { _ in
            // PHPicker workflow (no permission required)
            self.showPhotoPicker()
        })
        
        alert.addAction(UIAlertAction(title: "No Ahora", style: .cancel))
        
        present(alert, animated: true)
    }
}
```

**Trade-offs:**

- ‚úÖ Transparent privacy labels
- ‚úÖ Minimal data collection
- ‚úÖ User trust maximized
- ‚ö†Ô∏è "Photos" label inevitable (core feature)

---

### 2.5 App Store Review Guidelines

#### Restricci√≥n: Human Interface Guidelines + Review

**Problemas:**

```
App Store Review Common Rejections:
1. 2.1 - App Completeness
   * Crashes, broken features
   
2. 4.0 - Design
   * Poor UI, confusing UX
   * Not following HIG
   
3. 5.1.1 - Privacy
   * Misleading data collection
   * Missing privacy policy
   * Requesting unnecessary permissions
   
4. 5.1.2 - Data Use and Sharing
   * Third-party SDK disclosure required
   * OpenAI API usage must be disclosed
```

**Impacto en Bit√°cora:**

- ‚ö†Ô∏è **Vision LLM**: Must disclose OpenAI usage
- ‚ö†Ô∏è **Identity photos**: Justify camera/photos permission
- ‚úÖ **Local-first**: Less scrutiny

#### Mediaci√≥n: HIG Compliance + Transparent Disclosures

**Estrategia:**

```swift
// App Store Review Notes
"""
App Review Notes for Bit√°cora:

Third-Party APIs:
‚úÖ OpenAI GPT-4o Vision API
   Purpose: Image analysis for identity matching
   User control: Explicit opt-in required
   Data sent: Image bytes only (no PII)
   Data retention: None (responses cached locally)
   Privacy policy: [URL]

Permissions Justification:
‚úÖ Photos: Import conversations, analyze images
‚úÖ Camera: Capture biographical moments (future)
‚úÖ Notifications: Health alerts, import progress

Privacy-First Design:
‚úÖ Local-first architecture (YAML storage)
‚úÖ No user accounts required
‚úÖ No server-side data storage
‚úÖ User controls all data (export/delete)

Demo Account:
N/A - App works without account

Test Instructions:
1. Allow photos access (or select specific photos)
2. Import WhatsApp export (sample provided)
3. Analyze images with consent prompts
4. View health status (Vigilante)
5. Sync with Bit√°cora Corp (opt-in, can skip)
"""

// HIG compliance checklist
"""
Human Interface Guidelines Compliance:

‚úÖ Navigation: Tab bar + navigation stack
‚úÖ Layout: Adaptive (iPhone/iPad)
‚úÖ Dark Mode: Full support
‚úÖ Accessibility:
   - VoiceOver labels
   - Dynamic Type support
   - Color contrast WCAG AA
   
‚úÖ Onboarding:
   - Clear feature explanation
   - Permission requests with context
   - Skip option available
   
‚úÖ Error Handling:
   - Graceful degradation
   - Actionable error messages
   - Retry mechanisms
"""
```

**Trade-offs:**

- ‚úÖ Transparent disclosures ‚Üí smooth review
- ‚úÖ HIG compliance ‚Üí better UX
- ‚ö†Ô∏è Longer approval process (2-5 days)
- ‚úÖ User trust maximized

---

## üõ°Ô∏è PARTE 3: ESTRATEGIAS DE MEDIACI√ìN CROSS-PLATFORM

### 3.1 Arquitectura H√≠brida: Local-First + Cloud Optional

**Principio:**

```
Core Features ‚Üí 100% Local
Enhanced Features ‚Üí Cloud Optional (opt-in)

‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ         BIT√ÅCORA MOBILE                  ‚îÇ
‚îÇ                                          ‚îÇ
‚îÇ  LOCAL TIER (Always Available)          ‚îÇ
‚îÇ  ‚îú‚îÄ WhatsApp import (files)             ‚îÇ
‚îÇ  ‚îú‚îÄ Identity storage (YAML)             ‚îÇ
‚îÇ  ‚îú‚îÄ Cached analysis                     ‚îÇ
‚îÇ  ‚îî‚îÄ Basic search                        ‚îÇ
‚îÇ                                          ‚îÇ
‚îÇ  CLOUD TIER (Opt-In, Enhanced)          ‚îÇ
‚îÇ  ‚îú‚îÄ Vision LLM analysis                 ‚îÇ
‚îÇ  ‚îú‚îÄ Advanced identity matching          ‚îÇ
‚îÇ  ‚îú‚îÄ Bit√°cora Corp sync                  ‚îÇ
‚îÇ  ‚îî‚îÄ Cross-device sync (future)          ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
```

**Implementaci√≥n:**

```kotlin
// Feature flags per tier
sealed class FeatureTier {
    object Local : FeatureTier()
    object Cloud : FeatureTier()
}

class FeatureRegistry {
    val features = mapOf(
        "whatsapp_import" to FeatureTier.Local,
        "identity_storage" to FeatureTier.Local,
        "cached_analysis" to FeatureTier.Local,
        "vision_llm" to FeatureTier.Cloud,      // Opt-in
        "bitacora_corp_sync" to FeatureTier.Cloud, // Opt-in
    )
    
    fun isAvailable(feature: String): Boolean {
        return when (features[feature]) {
            FeatureTier.Local -> true
            FeatureTier.Cloud -> userOptedInToCloud()
            null -> false
        }
    }
}

// Graceful degradation
class ImageAnalyzer {
    suspend fun analyze(image: ByteArray): ImageAnalysis {
        return when {
            cloudEnabled && networkAvailable -> {
                try {
                    visionLLMClient.analyze(image)
                } catch (e: NetworkException) {
                    // Fallback to cached or defer
                    cache.get(image) ?: ImageAnalysis.deferred()
                }
            }
            else -> {
                // Local analysis or cached
                cache.get(image) ?: localAnalyzer.analyze(image)
            }
        }
    }
}
```

---

### 3.2 Battery-First Design

**Principio:**

```
NEVER surprise user with battery drain.

Transparency:
"This will use battery because we're calling OpenAI API"

User control:
‚Ä¢ Wi-Fi only mode (default)
‚Ä¢ Charging only mode (heavy tasks)
‚Ä¢ Manual mode (user triggers analysis)
```

**Implementaci√≥n:**

```swift
// Battery policy configuration
enum BatteryPolicy {
    case aggressive   // Any time
    case balanced     // Wi-Fi + >20% battery
    case conservative // Charging only
    case manual       // User-triggered only
}

class BatteryPolicyManager {
    var policy: BatteryPolicy = .balanced // Default
    
    func shouldRunTask(_ task: Task) -> Bool {
        let batteryLevel = UIDevice.current.batteryLevel
        let isCharging = UIDevice.current.batteryState == .charging
        let isWiFi = networkMonitor.isOnWiFi
        
        switch policy {
        case .aggressive:
            return true
            
        case .balanced:
            return (isWiFi && batteryLevel > 0.2) || isCharging
            
        case .conservative:
            return isCharging
            
        case .manual:
            return false // Wait for user trigger
        }
    }
    
    func explainDeferred(_ task: Task) -> String {
        switch policy {
        case .balanced where !networkMonitor.isOnWiFi:
            return "‚ö° Esperando Wi-Fi (configuraci√≥n: Balanced)"
        case .balanced where UIDevice.current.batteryLevel <= 0.2:
            return "üîã Bater√≠a baja (<20%). Conecta cargador o cambia a Aggressive"
        case .conservative where UIDevice.current.batteryState != .charging:
            return "üîå Esperando cargador (configuraci√≥n: Conservative)"
        default:
            return "Tarea diferida"
        }
    }
}
```

---

### 3.3 Vigilante Mobile Adaptation

**Problema:**

Desktop Vigilante: Background daemon 24/7  
Mobile Reality: Impossible

**Soluci√≥n:**

```
Mobile Vigilante Modes:

1. FOREGROUND MODE (app abierto)
   ‚îú‚îÄ Full health monitoring
   ‚îú‚îÄ Real-time alerts
   ‚îî‚îÄ User sees dashboard

2. BACKGROUND MODE (app en background)
   ‚îú‚îÄ iOS: BGAppRefreshTask cada ~15 min
   ‚îú‚îÄ Android: WorkManager cada 15 min
   ‚îî‚îÄ Limited checks (battery, storage)

3. CHARGING MODE (device charging)
   ‚îú‚îÄ BGProcessingTask (iOS)
   ‚îú‚îÄ WorkManager with charging constraint (Android)
   ‚îî‚îÄ Full vitality log analysis

4. DORMANT MODE (user disabled)
   ‚îú‚îÄ No background work
   ‚îú‚îÄ On-demand health check only
   ‚îî‚îÄ Respects user preference
```

**Implementaci√≥n:**

```kotlin
// Vigilante Mobile Adapter
class VigilanteMobileAdapter(
    private val vigilante: Vigilante,
    private val config: VigilanteConfig
) {
    fun onAppStateChanged(state: AppState) {
        when (state) {
            AppState.FOREGROUND -> {
                vigilante.setMode(VigilanteMode.FULL)
                vigilante.setCheckInterval(Duration.minutes(1))
            }
            
            AppState.BACKGROUND -> {
                vigilante.setMode(VigilanteMode.LIMITED)
                vigilante.setCheckInterval(Duration.minutes(15))
                scheduleBackgroundHealthCheck()
            }
            
            AppState.CHARGING -> {
                vigilante.setMode(VigilanteMode.COMPREHENSIVE)
                scheduleLongRunningAnalysis()
            }
            
            AppState.DORMANT -> {
                vigilante.pause()
                cancelAllScheduledTasks()
            }
        }
    }
    
    private fun scheduleBackgroundHealthCheck() {
        // iOS: BGAppRefreshTask
        // Android: WorkManager
        WorkManager.getInstance(context).enqueueUniquePeriodicWork(
            "vigilante_health_check",
            ExistingPeriodicWorkPolicy.REPLACE,
            PeriodicWorkRequestBuilder<VigilanteWorker>(
                15, TimeUnit.MINUTES
            ).build()
        )
    }
}
```

---

## üìä COMPARISON TABLE: Desktop vs Mobile

| Feature | Desktop | Android | iOS |
|---------|---------|---------|-----|
| **Background Daemon** | ‚úÖ 24/7 unrestricted | ‚ö†Ô∏è WorkManager 15min | ‚ö†Ô∏è BGAppRefresh 15min |
| **Storage Access** | ‚úÖ Full filesystem | ‚ö†Ô∏è SAF/MediaStore | ‚ö†Ô∏è Document Picker |
| **LLM Analysis** | ‚úÖ Unlimited | ‚ö†Ô∏è Battery-aware | ‚ö†Ô∏è Battery-aware |
| **Vitality Logs** | ‚úÖ Real-time 5min | ‚ö†Ô∏è 15min intervals | ‚ö†Ô∏è 15min intervals |
| **Corp Sync** | ‚úÖ Hourly | ‚ö†Ô∏è 2-24h delay | ‚ö†Ô∏è 2-24h delay |
| **User Permissions** | ‚úÖ Minimal | ‚ö†Ô∏è Runtime per-file | ‚ö†Ô∏è Runtime Limited Photos |
| **Battery Impact** | ‚ûñ Plugged in | ‚ö†Ô∏è User-visible impact | ‚ö†Ô∏è User-visible impact |
| **Privacy Policy** | ‚úÖ Optional | ‚ö†Ô∏è Required (Play) | ‚ö†Ô∏è Required (Nutrition Label) |

---

## üéØ IMPLEMENTATION ROADMAP

### Phase 1: Core Mobile Adaptation (v4.0, Q1 2027, 40h)

**Task 10.x.1 - Storage & Permissions**

```
- [ ] 10.x.1.1 - Android SAF integration (8h)
  * Document picker for WhatsApp import
  * MediaStore for identity photos
  * Persistable permissions management
  
- [ ] 10.x.1.2 - iOS Document Picker + PHPicker (8h)
  * WhatsApp export zip selection
  * PHPicker for identity photos
  * Limited Photos handling
  
- [ ] 10.x.1.3 - Permission explainers (4h)
  * Transparent pre-permission dialogs
  * Graceful degradation flows
  * Permission denied alternatives
```

### Phase 2: Battery-Aware Processing (v4.0, Q1 2027, 20h)

**Task 10.x.2 - Energy-Conscious Design**

```
- [ ] 10.x.2.1 - Battery policy manager (6h)
  * Aggressive/Balanced/Conservative modes
  * Charging detection
  * Low Power Mode adaptation
  
- [ ] 10.x.2.2 - Network-aware LLM client (6h)
  * Wi-Fi only mode (default)
  * Cellular data opt-in
  * Deferred analysis queue
  
- [ ] 10.x.2.3 - User battery dashboard (8h)
  * Estimated battery usage per feature
  * Battery savings recommendations
  * Real-time energy impact display
```

### Phase 3: Mobile Vigilante (v4.0, Q2 2027, 20h)

**Task 10.x.3 - Background Monitoring Adaptation**

```
- [ ] 10.x.3.1 - Android WorkManager integration (8h)
  * Periodic health checks (15 min)
  * Charging-only comprehensive analysis
  * Constraint-based scheduling
  
- [ ] 10.x.3.2 - iOS BGTaskScheduler (8h)
  * BGAppRefreshTask for health checks
  * BGProcessingTask for long analysis
  * Foreground service for imports
  
- [ ] 10.x.3.3 - Mobile Vigilante modes (4h)
  * Foreground/Background/Charging/Dormant
  * Adaptive check intervals
  * User-configurable monitoring
```

---

## ‚ú® FILOSOF√çA FINAL

### Principios de Dise√±o Mobile

1. **Respect Platform Conventions**
   - Android: Material Design, WorkManager, SAF
   - iOS: Human Interface Guidelines, BGTasks, PHPicker

2. **Battery-First Mindset**
   - Never surprise user with drain
   - Transparent energy usage
   - Heavy tasks only when charging

3. **Privacy-Preserving**
   - Request minimum permissions
   - Explain every permission
   - Graceful degradation without permissions

4. **Local-First, Cloud Optional**
   - Core features work offline
   - Enhanced features opt-in
   - User controls all data

5. **Honest Limitations**
   - No 24/7 background monitoring
   - Deferred analysis acceptable
   - User understands trade-offs

### Trade-Offs Acceptance

**Desktop ‚Üí Mobile sacrifices:**

- ‚ùå Real-time monitoring (24/7 ‚Üí 15min intervals)
- ‚ùå Automatic file access (manual selection required)
- ‚ùå Unlimited processing (battery-aware throttling)

**Gains:**

- ‚úÖ Portability (Bit√°cora in your pocket)
- ‚úÖ Privacy (stricter platform policies)
- ‚úÖ User trust (transparent limitations)

---

## üìö REFERENCIAS

- **Android Docs**: https://developer.android.com/guide/background
- **iOS Docs**: https://developer.apple.com/documentation/backgroundtasks
- **Play Store Policies**: https://play.google.com/about/developer-content-policy/
- **App Store Guidelines**: https://developer.apple.com/app-store/review/guidelines/
- **18.6_immune-system-vitality-logs.md**: Vigilante architecture (adapted for mobile)
- **CONFIG_PARAMETERS.md**: Battery policies, monitoring modes

---

**√öltima Actualizaci√≥n**: 2025-11-29 23:45:00  
**Branch**: `docs/mobile-platform-restrictions`  
**Status**: RESEARCH (v4.0+ 2027)  
**Tiempo Estimado**: 80h mobile adaptation  

üì±‚ú®üß≠
