```yaml
Archivo: ROADMAP_V2/00_VISION/18.6_immune-system-vitality-logs.md
VersiÃ³n: 1.0 - "Sistema Inmune de BitÃ¡cora - Monitoreo & Vitality"
Fecha CreaciÃ³n: 2025-11-29
Ãšltima ActualizaciÃ³n: 2025-11-29 23:30:00
Autor: Eduardo GJ + Claude (Copilot)
PropÃ³sito: DiseÃ±o del organismo de monitoreo constante, logs priorizados y protocolo BitÃ¡cora Corp
Estado: VISIONARY v3.0+ - Q4 2026 implementation
FilosofÃ­a: "BitÃ¡cora se cuida a sÃ­ misma. Monitorea, analiza, reporta. Siempre vigilante."
Related: CONFIG_PARAMETERS.md (immune system params), GUIA.md (metodologÃ­a)
Tiempo Estimado: 40h implementation (v3.0)
DecisiÃ³n ArquitectÃ³nica: DA-038 - Immune System & Vitality Logs
```

# ğŸ›¡ï¸ Sistema Inmune de BitÃ¡cora - Vitality Logs & Organism

> **SubtÃ­tulo**: *"Un organismo que se cuida a sÃ­ mismo, siempre vigilante, siempre preparado"*

> **FilosofÃ­a**: BitÃ¡cora no es solo una herramienta. Es un organismo vivo que monitorea su propia salud.

---

## ğŸŒ… PRELUDIO: La Necesidad del Sistema Inmune

### El Problema

Eduardo abre BitÃ¡cora despuÃ©s de 3 semanas de uso intensivo.

**Lo que NO sabe:**

- ğŸ”´ **3 errores crÃ­ticos** ocurrieron durante importaciones nocturnas
- ğŸŸ¡ **12 advertencias** sobre cache lleno (90% capacity)
- ğŸŸ¢ **47 eventos importantes** (nuevas identidades, anÃ¡lisis completados)
- ğŸ“Š **Performance degradation**: AnÃ¡lisis de imÃ¡genes 2x mÃ¡s lento que Semana 1
- ğŸ’¾ **Storage issues**: `/data/` creciÃ³ a 2.5GB (lÃ­mite 3GB)
- ğŸ”Œ **LLM costs**: $23 este mes (esperado: $15)

**Eduardo descubre los problemas solo cuando algo falla catastrÃ³ficamente.**

### La VisiÃ³n

**Â¿Y si BitÃ¡cora pudiera decir?**

> "Â¡Hola Eduardo! ğŸ‘‹
> 
> He estado monitoreando mi salud. AquÃ­ estÃ¡ mi **Vitality Report** de los Ãºltimos 7 dÃ­as:
> 
> âœ… **Salud General**: 87/100 (GOOD)
> 
> ğŸš¨ **3 Alertas CrÃ­ticas**:
> 1. WhatsApp import fallÃ³ 3 veces (corrupciÃ³n de archivos)
> 2. Cache identities.yaml casi lleno (90%)
> 3. LLM costs 50% sobre presupuesto
> 
> ğŸ“‹ **47 Eventos Importantes** (filtrados por prioridad)
> 
> ğŸ”„ **Actualizaciones Disponibles**:
> - Template 18.4 BQM v1.1 (mejoras Identity Matching)
> - BitÃ¡cora Corp Messenger: Nuevo protocolo disponible
> 
> Â¿Quieres que te muestre los detalles?"

**Esto es el Sistema Inmune de BitÃ¡cora.**

---

## ğŸ¯ FILOSOFÃA: Â¿QuÃ© Es Un Sistema Inmune?

### InspiraciÃ³n BiolÃ³gica

**Sistema inmune humano:**

- ğŸ” **Monitoreo constante**: Patrulla el cuerpo 24/7
- ğŸ§¬ **IdentificaciÃ³n de amenazas**: Distingue "self" vs "non-self"
- ğŸš¨ **Respuesta priorizada**: Ataque inmediato a crÃ­tico, vigilancia a bajo riesgo
- ğŸ“ **Memoria inmunolÃ³gica**: Aprende de infecciones pasadas
- ğŸ”„ **ReparaciÃ³n & adaptaciÃ³n**: Sana daÃ±os, evoluciona contra nuevas amenazas

**Sistema inmune BitÃ¡cora:**

- ğŸ” **Monitoreo constante**: Background daemon observando operaciones
- ğŸ§¬ **IdentificaciÃ³n de anomalÃ­as**: Errors, warnings, performance degradation
- ğŸš¨ **Logs priorizados**: Critical â†’ High â†’ Medium â†’ Low â†’ Info
- ğŸ“ **Historial de salud**: Vitality Logs analizados, patterns detectados
- ğŸ”„ **Auto-healing & updates**: Template updates, BitÃ¡cora Corp sync

### Los 3 Pilares del Sistema Inmune

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                  SISTEMA INMUNE BITÃCORA                â”‚
â”‚                                                          â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚  â”‚   VIGILANTE    â”‚  â”‚   ANALIZADOR   â”‚  â”‚ MENSAJERO â”‚ â”‚
â”‚  â”‚   (Organism)   â”‚  â”‚ (Vitality Logs)â”‚  â”‚  (Corp)   â”‚ â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â”‚         â†“                     â†“                  â†“       â”‚
â”‚    Monitoreo             PriorizaciÃ³n        Updates    â”‚
â”‚    Constante             & AnÃ¡lisis          & Sync     â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

---

## ğŸ§¬ COMPONENTE 1: El Vigilante (Monitoring Organism)

### Arquitectura del Organismo

```rust
// src/immune_system/vigilante.rs

pub struct Vigilante {
    /// Health monitoring daemon
    daemon: Arc<RwLock<MonitoringDaemon>>,
    
    /// Log collectors (per subsystem)
    collectors: Vec<Arc<dyn LogCollector>>,
    
    /// Anomaly detectors
    detectors: Vec<Arc<dyn AnomalyDetector>>,
    
    /// Vitality log writer
    vitality_writer: Arc<VitalityLogWriter>,
    
    /// Configuration
    config: VigilanteConfig,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VigilanteConfig {
    /// Enable background monitoring
    pub enabled: bool,
    
    /// Monitoring interval (seconds)
    pub check_interval_seconds: u64,
    
    /// Subsystems to monitor
    pub monitored_subsystems: Vec<Subsystem>,
    
    /// Anomaly detection sensitivity
    pub sensitivity: AnomalySensitivity,
    
    /// Max vitality log entries before rotation
    pub max_log_entries: usize,
    
    /// Alert thresholds
    pub thresholds: HealthThresholds,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum Subsystem {
    DataImport,        // WhatsAppDigester, etc.
    IdentitySystem,    // IdentityManager, BQM
    LLMServices,       // Vision/Text LLM calls
    Storage,           // Disk usage, file operations
    Cache,             // Cache hit rates, expiration
    Performance,       // Timing metrics
    Network,           // API calls, timeouts
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AnomalySensitivity {
    Paranoid,   // Alertar todo
    High,       // MayorÃ­a de anomalÃ­as
    Balanced,   // Solo importantes (default)
    Low,        // Solo crÃ­ticas
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HealthThresholds {
    /// Disk usage warning (%)
    pub disk_usage_warning: u8,  // 80%
    pub disk_usage_critical: u8, // 95%
    
    /// Cache size warning (MB)
    pub cache_size_warning: u64,    // 500MB
    pub cache_size_critical: u64,   // 1GB
    
    /// LLM cost warning ($/day)
    pub llm_cost_warning: f32,   // $7/day
    pub llm_cost_critical: f32,  // $10/day
    
    /// Performance degradation (multiplier)
    pub perf_degradation_warning: f32,  // 1.5x slower
    pub perf_degradation_critical: f32, // 2.5x slower
    
    /// Error rate warning (errors/hour)
    pub error_rate_warning: u32,   // 5 errors/hour
    pub error_rate_critical: u32,  // 20 errors/hour
}
```

### LogCollector Trait

```rust
#[async_trait]
pub trait LogCollector: Send + Sync {
    /// Subsystem this collector monitors
    fn subsystem(&self) -> Subsystem;
    
    /// Collect logs since last check
    async fn collect(&self) -> Result<Vec<LogEntry>>;
    
    /// Priority filter
    fn min_priority(&self) -> LogPriority;
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct LogEntry {
    pub timestamp: DateTime<Utc>,
    pub subsystem: Subsystem,
    pub priority: LogPriority,
    pub event_type: EventType,
    pub message: String,
    pub context: serde_json::Value, // Extra metadata
}

#[derive(Debug, Clone, Copy, PartialEq, Eq, PartialOrd, Ord, Serialize, Deserialize)]
pub enum LogPriority {
    Critical = 5,
    High = 4,
    Medium = 3,
    Low = 2,
    Info = 1,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum EventType {
    // Critical
    ImportFailure,
    DataCorruption,
    StorageFull,
    CriticalError,
    
    // High
    PerformanceDegradation,
    CacheFull,
    LLMCostOverage,
    NetworkTimeout,
    
    // Medium
    IdentityConflict,
    CacheMiss,
    SlowQuery,
    
    // Low
    NewIdentityCreated,
    ImportCompleted,
    CacheRotation,
    
    // Info
    HealthCheckPassed,
    BackupCreated,
    ConfigUpdated,
}
```

### AnomalyDetector Trait

```rust
#[async_trait]
pub trait AnomalyDetector: Send + Sync {
    /// Detect anomalies in log stream
    async fn detect(&self, logs: &[LogEntry]) -> Result<Vec<Anomaly>>;
    
    /// Historical baseline for comparison
    async fn baseline(&self) -> Result<HealthBaseline>;
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct Anomaly {
    pub detected_at: DateTime<Utc>,
    pub subsystem: Subsystem,
    pub severity: LogPriority,
    pub anomaly_type: AnomalyType,
    pub description: String,
    pub suggested_action: Option<String>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum AnomalyType {
    // Performance
    LatencySpike,          // OperaciÃ³n 2x+ mÃ¡s lenta
    ThroughputDrop,        // Procesar 50%- menos datos
    MemoryLeak,            // Uso RAM creciendo linealmente
    
    // Errors
    ErrorRateIncrease,     // Errores 3x+ normal
    RepeatedFailures,      // Mismo error 5+ veces
    CascadingFailures,     // Errores en cadena (Aâ†’Bâ†’C)
    
    // Resources
    DiskSpaceDecreasing,   // <10% libre
    CacheEvictionSpike,    // Cache thrashing
    LLMCostSpike,          // Costo 2x+ esperado
    
    // Patterns
    UnusualActivityTime,   // Actividad 3AM (inesperado)
    SuspiciousPattern,     // PatrÃ³n desconocido
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct HealthBaseline {
    /// Historical averages (last 30 days)
    pub avg_import_duration_seconds: f32,
    pub avg_llm_cost_per_day: f32,
    pub avg_cache_hit_rate: f32,
    pub avg_errors_per_day: u32,
    
    /// Performance percentiles
    pub p50_image_analysis_ms: u64,
    pub p95_image_analysis_ms: u64,
    pub p99_image_analysis_ms: u64,
}
```

### Monitoring Daemon Implementation

```rust
impl Vigilante {
    pub async fn new(config: VigilanteConfig) -> Result<Self> {
        let collectors = Self::init_collectors(&config)?;
        let detectors = Self::init_detectors(&config)?;
        let vitality_writer = Arc::new(VitalityLogWriter::new("data/vitality_logs/")?);
        
        let vigilante = Self {
            daemon: Arc::new(RwLock::new(MonitoringDaemon::new())),
            collectors,
            detectors,
            vitality_writer,
            config,
        };
        
        Ok(vigilante)
    }
    
    /// Start background monitoring daemon
    pub async fn start_monitoring(&self) -> Result<()> {
        if !self.config.enabled {
            log::info!("Vigilante monitoring disabled in config");
            return Ok(());
        }
        
        log::info!("ğŸ›¡ï¸ Starting Immune System - Vigilante monitoring daemon");
        
        let vigilante = self.clone();
        tokio::spawn(async move {
            vigilante.monitoring_loop().await;
        });
        
        Ok(())
    }
    
    async fn monitoring_loop(&self) {
        let mut interval = tokio::time::interval(
            Duration::from_secs(self.config.check_interval_seconds)
        );
        
        loop {
            interval.tick().await;
            
            if let Err(e) = self.health_check().await {
                log::error!("Vigilante health check failed: {}", e);
            }
        }
    }
    
    async fn health_check(&self) -> Result<()> {
        // Step 1: Collect logs from all subsystems
        let mut all_logs = Vec::new();
        
        for collector in &self.collectors {
            match collector.collect().await {
                Ok(logs) => {
                    log::debug!("Collected {} logs from {:?}", logs.len(), collector.subsystem());
                    all_logs.extend(logs);
                }
                Err(e) => {
                    log::warn!("Failed to collect logs from {:?}: {}", collector.subsystem(), e);
                }
            }
        }
        
        // Step 2: Detect anomalies
        let mut all_anomalies = Vec::new();
        
        for detector in &self.detectors {
            match detector.detect(&all_logs).await {
                Ok(anomalies) => {
                    all_anomalies.extend(anomalies);
                }
                Err(e) => {
                    log::warn!("Anomaly detection failed: {}", e);
                }
            }
        }
        
        // Step 3: Analyze and prioritize
        let analyzed = self.analyze_health(&all_logs, &all_anomalies).await?;
        
        // Step 4: Write to Vitality Log
        self.vitality_writer.write_entry(analyzed).await?;
        
        // Step 5: Alert if critical
        if analyzed.health_score < 50 {
            self.alert_user(&analyzed).await?;
        }
        
        log::debug!("âœ… Health check complete. Score: {}/100", analyzed.health_score);
        
        Ok(())
    }
    
    async fn analyze_health(
        &self,
        logs: &[LogEntry],
        anomalies: &[Anomaly],
    ) -> Result<VitalityEntry> {
        // Count by priority
        let critical_count = logs.iter().filter(|l| l.priority == LogPriority::Critical).count();
        let high_count = logs.iter().filter(|l| l.priority == LogPriority::High).count();
        let medium_count = logs.iter().filter(|l| l.priority == LogPriority::Medium).count();
        
        // Calculate health score (0-100)
        let health_score = self.calculate_health_score(critical_count, high_count, medium_count, anomalies.len());
        
        // Determine health status
        let status = match health_score {
            90..=100 => HealthStatus::Excellent,
            70..=89 => HealthStatus::Good,
            50..=69 => HealthStatus::Fair,
            30..=49 => HealthStatus::Poor,
            _ => HealthStatus::Critical,
        };
        
        Ok(VitalityEntry {
            timestamp: Utc::now(),
            health_score,
            status,
            critical_alerts: critical_count as u32,
            high_alerts: high_count as u32,
            medium_alerts: medium_count as u32,
            anomalies_detected: anomalies.len() as u32,
            logs: logs.to_vec(),
            anomalies: anomalies.to_vec(),
            recommendations: self.generate_recommendations(logs, anomalies),
        })
    }
    
    fn calculate_health_score(
        &self,
        critical: usize,
        high: usize,
        medium: usize,
        anomalies: usize,
    ) -> u8 {
        let mut score = 100.0;
        
        // Deduct points for issues
        score -= (critical as f32) * 20.0;  // -20 per critical
        score -= (high as f32) * 5.0;       // -5 per high
        score -= (medium as f32) * 1.0;     // -1 per medium
        score -= (anomalies as f32) * 3.0;  // -3 per anomaly
        
        // Clamp to 0-100
        score.max(0.0).min(100.0) as u8
    }
    
    fn generate_recommendations(
        &self,
        logs: &[LogEntry],
        anomalies: &[Anomaly],
    ) -> Vec<String> {
        let mut recommendations = Vec::new();
        
        // Check for repeated import failures
        let import_failures = logs.iter()
            .filter(|l| l.event_type == EventType::ImportFailure)
            .count();
        
        if import_failures >= 3 {
            recommendations.push(
                "âš ï¸ MÃºltiples fallas de importaciÃ³n detectadas. Considera verificar integridad de archivos.".to_string()
            );
        }
        
        // Check for cache issues
        let cache_full = anomalies.iter()
            .any(|a| matches!(a.anomaly_type, AnomalyType::CacheEvictionSpike));
        
        if cache_full {
            recommendations.push(
                "ğŸ’¾ Cache experimentando thrashing. Considera aumentar cache size o reducir cache_duration.".to_string()
            );
        }
        
        // Check for LLM cost overages
        let llm_overage = anomalies.iter()
            .any(|a| matches!(a.anomaly_type, AnomalyType::LLMCostSpike));
        
        if llm_overage {
            recommendations.push(
                "ğŸ’° Costos LLM sobre presupuesto. Considera habilitar cache mÃ¡s agresivo o reducir analysis_strategy.".to_string()
            );
        }
        
        // More sophisticated recommendations...
        
        recommendations
    }
    
    async fn alert_user(&self, vitality: &VitalityEntry) -> Result<()> {
        // Desktop notification
        #[cfg(feature = "desktop-notifications")]
        {
            self.send_desktop_notification(vitality)?;
        }
        
        // Terminal alert
        println!("\nğŸš¨ BITÃCORA HEALTH ALERT ğŸš¨");
        println!("Health Score: {}/100 ({})", vitality.health_score, vitality.status);
        println!("Critical Issues: {}", vitality.critical_alerts);
        println!("\nRun `bitacora health` for details.\n");
        
        Ok(())
    }
}
```

---

## ğŸ“Š COMPONENTE 2: Vitality Logs (AnÃ¡lisis & PriorizaciÃ³n)

### VitalityEntry Structure

```rust
#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VitalityEntry {
    pub timestamp: DateTime<Utc>,
    pub health_score: u8,           // 0-100
    pub status: HealthStatus,
    
    // Alert counts
    pub critical_alerts: u32,
    pub high_alerts: u32,
    pub medium_alerts: u32,
    pub anomalies_detected: u32,
    
    // Full logs (filtered by priority)
    pub logs: Vec<LogEntry>,
    pub anomalies: Vec<Anomaly>,
    
    // AI-generated recommendations
    pub recommendations: Vec<String>,
}

#[derive(Debug, Clone, Copy, Serialize, Deserialize)]
pub enum HealthStatus {
    Excellent,  // 90-100
    Good,       // 70-89
    Fair,       // 50-69
    Poor,       // 30-49
    Critical,   // 0-29
}

impl fmt::Display for HealthStatus {
    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {
        match self {
            HealthStatus::Excellent => write!(f, "EXCELLENT âœ¨"),
            HealthStatus::Good => write!(f, "GOOD âœ…"),
            HealthStatus::Fair => write!(f, "FAIR âš ï¸"),
            HealthStatus::Poor => write!(f, "POOR ğŸ”¶"),
            HealthStatus::Critical => write!(f, "CRITICAL ğŸš¨"),
        }
    }
}
```

### Vitality Log Storage

```yaml
# data/vitality_logs/vitality_2025-11-29.yaml

- timestamp: 2025-11-29T23:00:00Z
  health_score: 87
  status: Good
  critical_alerts: 0
  high_alerts: 2
  medium_alerts: 5
  anomalies_detected: 1
  
  logs:
    - timestamp: 2025-11-29T22:45:00Z
      subsystem: LLMServices
      priority: High
      event_type: LLMCostOverage
      message: "LLM costs today: $7.50 (budget: $5.00)"
      context:
        total_cost: 7.50
        budget: 5.00
        overage_pct: 50.0
    
    - timestamp: 2025-11-29T22:30:00Z
      subsystem: Cache
      priority: High
      event_type: CacheFull
      message: "Identity cache at 90% capacity"
      context:
        cache_size_mb: 450
        max_size_mb: 500
        usage_pct: 90
    
    # ... more logs
  
  anomalies:
    - detected_at: 2025-11-29T23:00:00Z
      subsystem: LLMServices
      severity: High
      anomaly_type: LLMCostSpike
      description: "LLM cost 50% above baseline"
      suggested_action: "Enable aggressive caching or reduce Vision LLM frequency"
  
  recommendations:
    - "ğŸ’° Costos LLM sobre presupuesto. Considera habilitar cache mÃ¡s agresivo."
    - "ğŸ’¾ Cache al 90%. Considera rotaciÃ³n o aumento de lÃ­mite."

- timestamp: 2025-11-29T22:00:00Z
  health_score: 92
  status: Excellent
  # ... (anterior health check)
```

### CLI: Consultar Vitality Logs

```bash
# Ver salud actual
$ bitacora health

ğŸ›¡ï¸ BITÃCORA HEALTH STATUS
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Health Score: 87/100 (GOOD âœ…)
Last Check: 5 minutes ago

ğŸš¨ Critical Alerts: 0
âš ï¸  High Priority: 2
ğŸ“‹ Medium Priority: 5

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ” Recent Issues (Last 24h):

HIGH: LLM costs over budget ($7.50 / $5.00)
  â†’ Suggested: Enable aggressive caching

HIGH: Identity cache at 90% capacity
  â†’ Suggested: Rotate cache or increase limit

MEDIUM: 3 import warnings (file corruption?)
  â†’ Suggested: Verify file integrity

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ’¡ Recommendations:
  1. Consider reducing Vision LLM frequency
  2. Review cache rotation policy
  3. Check WhatsApp import source files

Run `bitacora health --details` for full report.
```

```bash
# Ver detalles completos
$ bitacora health --details

# Ver historial (Ãºltimos 7 dÃ­as)
$ bitacora health --history 7d

# Ver solo alertas crÃ­ticas
$ bitacora health --filter critical

# Exportar reporte
$ bitacora health --export vitality_report_2025-11-29.json
```

---

## ğŸ”„ COMPONENTE 3: BitÃ¡cora Corp Messenger (Updates & Sync)

### El Protocolo Mensajero

**Concepto:**

BitÃ¡cora Corp mantiene:

- âœ… **Template updates**: Nuevas versiones de documentos (18.4, 18.5, etc.)
- âœ… **Feature announcements**: Nuevas capabilities (v1.5, v2.0)
- âœ… **Security patches**: Bugfixes crÃ­ticos
- âœ… **Community insights**: Patterns detectados en la comunidad BitÃ¡cora

**Messenger protocol:**

BitÃ¡cora local periÃ³dicamente:

1. Genera **Vitality Summary** (health score, anomalies, usage patterns)
2. Se conecta a BitÃ¡cora Corp API (opcional, opt-in)
3. EnvÃ­a summary anÃ³nimo (no PII)
4. Recibe updates disponibles

### Messenger Implementation

```rust
// src/immune_system/messenger.rs

pub struct BitacoraCorpMessenger {
    client: reqwest::Client,
    config: MessengerConfig,
    vitality_reader: Arc<VitalityLogReader>,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct MessengerConfig {
    /// Enable sync with BitÃ¡cora Corp
    pub enabled: bool,
    
    /// API endpoint
    pub corp_api_url: String,
    
    /// Sync frequency (hours)
    pub sync_interval_hours: u64,
    
    /// Send anonymous vitality stats
    pub send_telemetry: bool,
    
    /// Auto-download template updates
    pub auto_download_templates: bool,
}

impl BitacoraCorpMessenger {
    pub async fn sync(&self) -> Result<SyncReport> {
        if !self.config.enabled {
            return Ok(SyncReport::disabled());
        }
        
        log::info!("ğŸ“¡ Syncing with BitÃ¡cora Corp...");
        
        // Step 1: Generate vitality summary
        let vitality_summary = self.generate_vitality_summary().await?;
        
        // Step 2: Send to Corp (if telemetry enabled)
        let telemetry_response = if self.config.send_telemetry {
            Some(self.send_vitality_telemetry(&vitality_summary).await?)
        } else {
            None
        };
        
        // Step 3: Check for updates
        let available_updates = self.check_for_updates().await?;
        
        // Step 4: Download templates (if auto-download)
        let downloaded_templates = if self.config.auto_download_templates {
            self.download_template_updates(&available_updates).await?
        } else {
            Vec::new()
        };
        
        Ok(SyncReport {
            synced_at: Utc::now(),
            vitality_summary,
            telemetry_sent: telemetry_response.is_some(),
            available_updates,
            downloaded_templates,
        })
    }
    
    async fn generate_vitality_summary(&self) -> Result<VitalitySummary> {
        // Read last 7 days of vitality logs
        let logs = self.vitality_reader.read_last_n_days(7).await?;
        
        // Aggregate statistics
        let avg_health_score = logs.iter()
            .map(|l| l.health_score as f32)
            .sum::<f32>() / logs.len() as f32;
        
        let total_critical = logs.iter().map(|l| l.critical_alerts).sum();
        let total_high = logs.iter().map(|l| l.high_alerts).sum();
        let total_anomalies = logs.iter().map(|l| l.anomalies_detected).sum();
        
        // Detect patterns (most common issues)
        let common_issues = self.detect_common_issues(&logs);
        
        Ok(VitalitySummary {
            period_days: 7,
            avg_health_score: avg_health_score as u8,
            total_critical_alerts: total_critical,
            total_high_alerts: total_high,
            total_anomalies,
            common_issues,
            bitacora_version: env!("CARGO_PKG_VERSION").to_string(),
        })
    }
    
    async fn send_vitality_telemetry(&self, summary: &VitalitySummary) -> Result<TelemetryResponse> {
        // Anonymous telemetry (NO PII)
        let telemetry = AnonymousTelemetry {
            bitacora_version: summary.bitacora_version.clone(),
            health_score: summary.avg_health_score,
            alert_counts: AlertCounts {
                critical: summary.total_critical_alerts,
                high: summary.total_high_alerts,
            },
            common_issues: summary.common_issues.clone(),
            // NO user data, NO file paths, NO identities
        };
        
        let response = self.client
            .post(&format!("{}/telemetry", self.config.corp_api_url))
            .json(&telemetry)
            .send()
            .await?;
        
        response.json().await
    }
    
    async fn check_for_updates(&self) -> Result<Vec<AvailableUpdate>> {
        let response = self.client
            .get(&format!("{}/updates", self.config.corp_api_url))
            .query(&[("version", env!("CARGO_PKG_VERSION"))])
            .send()
            .await?;
        
        response.json().await
    }
    
    async fn download_template_updates(&self, updates: &[AvailableUpdate]) -> Result<Vec<String>> {
        let mut downloaded = Vec::new();
        
        for update in updates {
            if let UpdateType::Template { template_name, version } = &update.update_type {
                log::info!("ğŸ“¥ Downloading template: {} v{}", template_name, version);
                
                let content = self.download_template_content(update).await?;
                
                // Save to templates/
                let path = format!("templates/{}_v{}.md", template_name, version);
                tokio::fs::write(&path, content).await?;
                
                downloaded.push(path);
            }
        }
        
        Ok(downloaded)
    }
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct VitalitySummary {
    pub period_days: u32,
    pub avg_health_score: u8,
    pub total_critical_alerts: u32,
    pub total_high_alerts: u32,
    pub total_anomalies: u32,
    pub common_issues: Vec<CommonIssue>,
    pub bitacora_version: String,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct CommonIssue {
    pub issue_type: String,
    pub frequency: u32,
    pub severity: LogPriority,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct AvailableUpdate {
    pub id: String,
    pub update_type: UpdateType,
    pub version: String,
    pub release_date: DateTime<Utc>,
    pub description: String,
    pub critical: bool,
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub enum UpdateType {
    Template {
        template_name: String,
        version: String,
    },
    SecurityPatch {
        patch_id: String,
    },
    FeatureAnnouncement {
        feature_name: String,
    },
}

#[derive(Debug, Clone, Serialize, Deserialize)]
pub struct SyncReport {
    pub synced_at: DateTime<Utc>,
    pub vitality_summary: VitalitySummary,
    pub telemetry_sent: bool,
    pub available_updates: Vec<AvailableUpdate>,
    pub downloaded_templates: Vec<String>,
}
```

### CLI: Messenger Commands

```bash
# Sync manual
$ bitacora sync

ğŸ“¡ Syncing with BitÃ¡cora Corp...

âœ… Vitality Summary Generated (7 days)
   Health Score: 87/100 (GOOD)
   Critical Alerts: 2
   High Alerts: 8

âœ… Telemetry Sent (anonymous)

ğŸ”„ Checking for updates...

ğŸ“¥ 3 Updates Available:
  1. [TEMPLATE] 18.4 BQM Identity v1.1 (2025-12-01)
     â†’ Improved identity matching accuracy
  2. [SECURITY] Patch #2025-001 (CRITICAL)
     â†’ Fix YAML parser vulnerability
  3. [FEATURE] v1.5 Face Embeddings (2026-01-15)
     â†’ MobileFaceNet integration available

ğŸ“¥ Auto-downloaded: 18.4 BQM Identity v1.1

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ’¡ Recommendations from BitÃ¡cora Corp:
  â€¢ Your LLM costs are 2x community average
    Consider enabling aggressive caching
  
  â€¢ 87% of users with similar health patterns
    enabled HumanRecognition mini-LLM training

Run `bitacora updates` to see all available updates.
```

```bash
# Ver updates disponibles
$ bitacora updates

# Aplicar update especÃ­fico
$ bitacora update apply template-18.4-v1.1

# Configurar auto-sync
$ bitacora config set messenger.auto_sync true
```

---

## ğŸ—ï¸ ARQUITECTURA COMPLETA

### System Diagram

```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚                    BITÃCORA (Main Process)                   â”‚
â”‚                                                               â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚            Normal Operations Layer                     â”‚   â”‚
â”‚  â”‚  â€¢ WhatsAppDigester                                   â”‚   â”‚
â”‚  â”‚  â€¢ IdentityManager                                    â”‚   â”‚
â”‚  â”‚  â€¢ LLM Services                                       â”‚   â”‚
â”‚  â”‚  â€¢ IceBreaker                                         â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                           â†“â†‘ Observability                    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚         IMMUNE SYSTEM (Background Daemon)              â”‚   â”‚
â”‚  â”‚                                                         â”‚   â”‚
â”‚  â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚   â”‚
â”‚  â”‚  â”‚  VIGILANTE    â”‚  â”‚  VITALITY    â”‚  â”‚ MESSENGER  â”‚ â”‚   â”‚
â”‚  â”‚  â”‚  (Monitor)    â”‚  â”‚  LOGS        â”‚  â”‚ (Corp Sync)â”‚ â”‚   â”‚
â”‚  â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚   â”‚
â”‚  â”‚         â†“                  â†“                 â†“          â”‚   â”‚
â”‚  â”‚  LogCollectors      VitalityWriter    BitÃ¡coraCorp   â”‚   â”‚
â”‚  â”‚  AnomalyDetectors   HealthAnalyzer    API Client     â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚                                                               â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                           â†“
         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
         â”‚    data/vitality_logs/              â”‚
         â”‚    â€¢ vitality_2025-11-29.yaml      â”‚
         â”‚    â€¢ vitality_2025-11-28.yaml      â”‚
         â”‚    â€¢ ...                           â”‚
         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### Data Flow

1. **Normal Operations** (WhatsApp import, identity linking, etc.)
   â†’ Emit logs to LogCollectors

2. **Vigilante** (every `check_interval_seconds`)
   â†’ Collect logs from all subsystems
   â†’ Detect anomalies
   â†’ Analyze health
   â†’ Write VitalityEntry

3. **User** (on-demand)
   â†’ `bitacora health` â†’ Read vitality logs
   â†’ `bitacora sync` â†’ Messenger sync with Corp

4. **BitÃ¡cora Corp Messenger** (every `sync_interval_hours`)
   â†’ Generate vitality summary
   â†’ Send anonymous telemetry (opt-in)
   â†’ Check for updates
   â†’ Download templates (opt-in)

---

## ğŸ§ª TESTING STRATEGY

### Unit Tests

```rust
#[cfg(test)]
mod tests {
    use super::*;
    
    #[tokio::test]
    async fn test_health_score_calculation() {
        let vigilante = Vigilante::new(VigilanteConfig::default()).await.unwrap();
        
        // No issues
        assert_eq!(vigilante.calculate_health_score(0, 0, 0, 0), 100);
        
        // 1 critical
        assert_eq!(vigilante.calculate_health_score(1, 0, 0, 0), 80);
        
        // 2 high
        assert_eq!(vigilante.calculate_health_score(0, 2, 0, 0), 90);
        
        // Mixed
        let score = vigilante.calculate_health_score(1, 3, 5, 2);
        assert!(score >= 50 && score <= 70); // Fair range
    }
    
    #[tokio::test]
    async fn test_anomaly_detection_latency_spike() {
        let detector = PerformanceAnomalyDetector::new();
        
        let logs = vec![
            LogEntry {
                timestamp: Utc::now(),
                subsystem: Subsystem::DataImport,
                priority: LogPriority::Medium,
                event_type: EventType::SlowQuery,
                message: "Image analysis took 5000ms (expected 500ms)".to_string(),
                context: json!({ "duration_ms": 5000, "baseline_ms": 500 }),
            },
        ];
        
        let anomalies = detector.detect(&logs).await.unwrap();
        
        assert_eq!(anomalies.len(), 1);
        assert!(matches!(anomalies[0].anomaly_type, AnomalyType::LatencySpike));
    }
    
    #[tokio::test]
    async fn test_vitality_log_persistence() {
        let writer = VitalityLogWriter::new("test_data/vitality_logs/").unwrap();
        
        let entry = VitalityEntry {
            timestamp: Utc::now(),
            health_score: 87,
            status: HealthStatus::Good,
            critical_alerts: 0,
            high_alerts: 2,
            medium_alerts: 5,
            anomalies_detected: 1,
            logs: vec![],
            anomalies: vec![],
            recommendations: vec!["Test recommendation".to_string()],
        };
        
        writer.write_entry(entry.clone()).await.unwrap();
        
        // Read back
        let reader = VitalityLogReader::new("test_data/vitality_logs/");
        let read_entry = reader.read_latest().await.unwrap();
        
        assert_eq!(read_entry.health_score, 87);
        assert_eq!(read_entry.status, HealthStatus::Good);
    }
}
```

### Integration Tests

```rust
#[tokio::test]
async fn test_full_immune_system_lifecycle() {
    // Start Vigilante
    let config = VigilanteConfig {
        enabled: true,
        check_interval_seconds: 1, // Fast for testing
        monitored_subsystems: vec![Subsystem::DataImport, Subsystem::LLMServices],
        sensitivity: AnomalySensitivity::High,
        max_log_entries: 1000,
        thresholds: HealthThresholds::default(),
    };
    
    let vigilante = Vigilante::new(config).await.unwrap();
    vigilante.start_monitoring().await.unwrap();
    
    // Simulate normal operations
    simulate_whatsapp_import().await;
    simulate_identity_linking().await;
    
    // Wait for health check
    tokio::time::sleep(Duration::from_secs(2)).await;
    
    // Read vitality log
    let reader = VitalityLogReader::new("data/vitality_logs/");
    let latest = reader.read_latest().await.unwrap();
    
    assert!(latest.health_score >= 80); // Should be healthy
    assert_eq!(latest.critical_alerts, 0); // No critical issues
}
```

---

## ğŸ“ˆ IMPLEMENTATION ROADMAP

### Phase 1: Vigilante Core (v3.0, Week 1-2, 16h)

**Task 9.x.1 - Monitoring Infrastructure**

```
- [ ] 9.x.1.1 - Vigilante struct + config (4h)
  * VigilanteConfig with thresholds
  * Background daemon loop
  * LogCollector trait
  
- [ ] 9.x.1.2 - Log collectors (6h)
  * DataImportCollector
  * IdentitySystemCollector
  * LLMServicesCollector
  * StorageCollector
  
- [ ] 9.x.1.3 - AnomalyDetector trait (4h)
  * PerformanceAnomalyDetector
  * ResourceAnomalyDetector
  * ErrorPatternDetector
  
- [ ] 9.x.1.4 - Tests (2h)
  * Unit: health score calculation
  * Integration: full monitoring cycle
```

### Phase 2: Vitality Logs (v3.0, Week 2, 8h)

**Task 9.x.2 - Log Analysis & Persistence**

```
- [ ] 9.x.2.1 - VitalityEntry struct (2h)
  * Health score, status, alerts
  * Logs + anomalies storage
  * Recommendations generation
  
- [ ] 9.x.2.2 - VitalityLogWriter (3h)
  * YAML persistence
  * Daily log rotation
  * Retention policy (30 days default)
  
- [ ] 9.x.2.3 - CLI health command (3h)
  * `bitacora health`
  * `bitacora health --details`
  * `bitacora health --history 7d`
```

### Phase 3: BitÃ¡cora Corp Messenger (v3.0, Week 3-4, 16h)

**Task 9.x.3 - Corp Sync & Updates**

```
- [ ] 9.x.3.1 - Messenger client (6h)
  * BitacoraCorpMessenger struct
  * VitalitySummary generation
  * Anonymous telemetry (opt-in)
  
- [ ] 9.x.3.2 - Update protocol (6h)
  * Check for template updates
  * Download & apply patches
  * Security patch detection
  
- [ ] 9.x.3.3 - CLI sync command (4h)
  * `bitacora sync`
  * `bitacora updates`
  * `bitacora update apply <id>`
```

---

## ğŸ¨ USER EXPERIENCE

### First Run Experience

```bash
$ bitacora --help

bitacora v3.0.0

USAGE:
    bitacora <SUBCOMMAND>

SUBCOMMANDS:
    import     Import conversations (WhatsApp, Telegram, etc.)
    health     Check BitÃ¡cora system health
    sync       Sync with BitÃ¡cora Corp (updates, templates)
    config     Manage configuration
    ...

ğŸ›¡ï¸ Immune System: ACTIVE
   Last health check: 2 minutes ago (Score: 92/100 GOOD âœ…)
```

### Daily Interaction

**Scenario 1: Everything Good**

```bash
$ bitacora health

ğŸ›¡ï¸ BITÃCORA HEALTH STATUS
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Health Score: 92/100 (EXCELLENT âœ¨)
Last Check: 3 minutes ago

ğŸš¨ Critical Alerts: 0
âš ï¸  High Priority: 0
ğŸ“‹ Medium Priority: 2

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

All systems operating normally. ğŸ‰

Run `bitacora sync` to check for updates.
```

**Scenario 2: Issues Detected**

```bash
$ bitacora health

ğŸ›¡ï¸ BITÃCORA HEALTH STATUS
â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

Health Score: 67/100 (FAIR âš ï¸)
Last Check: 1 minute ago

ğŸš¨ Critical Alerts: 1
âš ï¸  High Priority: 3
ğŸ“‹ Medium Priority: 8

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸš¨ CRITICAL ISSUES:

1. STORAGE FULL (95% disk usage)
   â†’ Suggested: Delete old imports or increase storage

âš ï¸  HIGH PRIORITY ISSUES:

1. LLM costs 80% over budget ($9/day)
   â†’ Suggested: Enable aggressive caching
   
2. Identity cache thrashing (90% eviction rate)
   â†’ Suggested: Increase cache size
   
3. Import failures (5 in last hour)
   â†’ Suggested: Verify file integrity

â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”â”

ğŸ’¡ Recommendations:
  1. Free up disk space immediately
  2. Review LLM usage patterns
  3. Check WhatsApp import source

Run `bitacora health --fix` for guided repair.
```

---

## ğŸŒŸ FILOSOFÃA FINAL

### Por QuÃ© Necesitamos el Sistema Inmune

**BitÃ¡cora es un organismo complejo:**

- Importa datos (digestiÃ³n)
- Analiza con LLMs (cogniciÃ³n)
- Almacena identidades (memoria)
- Responde a queries (reflexiÃ³n)

**Sin sistema inmune:**

- âŒ Problemas silenciosos acumulan
- âŒ Costos escalan sin aviso
- âŒ Performance degrada gradualmente
- âŒ Usuario descubre problemas tarde

**Con sistema inmune:**

- âœ… Monitoreo constante
- âœ… Alertas proactivas
- âœ… Recomendaciones inteligentes
- âœ… Auto-healing capabilities
- âœ… EvoluciÃ³n guiada (updates, templates)

### Principios del Immune System

1. **Vigilancia constante**: Background daemon, no overhead user
2. **PriorizaciÃ³n inteligente**: Critical â†’ High â†’ Medium â†’ Low â†’ Info
3. **Contexto histÃ³rico**: Baseline learning, anomaly detection
4. **Transparencia total**: Logs YAML legibles, reasoning explÃ­cito
5. **Privacidad first**: Telemetry 100% opt-in, anÃ³nima
6. **EvoluciÃ³n colaborativa**: BitÃ¡cora Corp sync, community insights

### Trade-offs Aceptados

**Performance overhead:**

- Monitoring daemon: ~0.1% CPU
- Log collection: ~50MB/week
- Vitality analysis: ~10ms per check
- **Verdict**: Negligible for benefit

**Complexity:**

- +3 major components (Vigilante, VitalityLogs, Messenger)
- +40h implementation
- **Verdict**: Complexity hidden, UX simple

**Privacy concerns:**

- Telemetry opt-in (default: disabled)
- Anonymous only (no PII)
- Local-first (vitality logs local)
- **Verdict**: User controls everything

---

## ğŸ“š REFERENCIAS

- **CONFIG_PARAMETERS.md**: Immune system configuration parameters
- **GUIA.md**: MetodologÃ­a de documentaciÃ³n
- **18.4_bqm-identity-system-v1.md**: Identity system monitored by Vigilante
- **18.5_bqm-quantum-identity-vision-v2.md**: BQM v2.0+ monitoring

---

**Ãšltima ActualizaciÃ³n**: 2025-11-29 23:30:00  
**Branch**: `docs/immune-system-vitality-logs`  
**Status**: VISIONARY (v3.0+ Q4 2026)  
**Tiempo Estimado**: 40h implementation  

ğŸ›¡ï¸âœ¨ğŸ§­
