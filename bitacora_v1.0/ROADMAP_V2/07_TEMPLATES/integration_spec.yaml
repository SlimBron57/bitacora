name: "integration_spec"
category: "technical"
version: "1.0.0"
description: "Template para documentar especificaciones de integraciÃ³n entre componentes de BitÃ¡cora"

# Triggers que activan este template
trigger_patterns:
  - "**/03_INTEGRACION/*.md"
  - "integration design"
  - "component integration"
  - "integraciÃ³n de componentes"

# Personalidad del template
personality:
  tone: "systematic_clear"
  depth: "integration-focused"
  style: "flow-oriented"
  approach: "pipeline-thinking"  # Pensar en flujo de datos

# Estructura obligatoria
structure:
  audit_header:
    required: true
    format: "yaml"
    fields:
      - archivo
      - version
      - fecha_creacion
      - autor
      - proposito
      - estado
      - relacionado_con
      - componentes_integrados  # Lista de componentes que conecta

  sections:
    - name: "purpose"
      title: "ğŸ¯ PROPÃ“SITO DE LA INTEGRACIÃ“N"
      required: true
      prompt: |
        Explicar:
        - Â¿QuÃ© componentes se integran?
        - Â¿Por quÃ© necesitan comunicarse?
        - Â¿QuÃ© valor aÃ±ade la integraciÃ³n?
        - Â¿QuÃ© pasarÃ­a sin esta integraciÃ³n?
      
    - name: "integration_overview"
      title: "ğŸ”„ VISIÃ“N GENERAL DEL FLUJO"
      required: true
      prompt: |
        Diagrama de flujo de datos:
        ```
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ Component A â”‚
        â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
               â”‚ Data: Input
               â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ Integration â”‚ â† Transformation/Validation
        â”‚   Layer     â”‚
        â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”˜
               â”‚ Data: Output
               â–¼
        â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
        â”‚ Component B â”‚
        â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
        ```
        
        DescripciÃ³n de cada etapa del flujo.
      
    - name: "data_contracts"
      title: "ğŸ“‹ CONTRATOS DE DATOS"
      required: true
      prompt: |
        Definir interfaces entre componentes:
        
        ### Input Contract (Component A â†’ Integration)
        ```rust
        pub struct InputData {
            // Campos requeridos
            pub required_field: Type,
            
            // Campos opcionales
            pub optional_field: Option<Type>,
        }
        
        // Validaciones
        impl InputData {
            pub fn validate(&self) -> Result<(), ValidationError>;
        }
        ```
        
        ### Output Contract (Integration â†’ Component B)
        ```rust
        pub struct OutputData {
            // Campos transformados
        }
        ```
      
    - name: "transformation_logic"
      title: "âš™ï¸ LÃ“GICA DE TRANSFORMACIÃ“N"
      required: true
      prompt: |
        CÃ³mo se transforman los datos:
        
        ```rust
        pub struct IntegrationLayer {
            component_a: ComponentA,
            component_b: ComponentB,
        }
        
        impl IntegrationLayer {
            pub fn transform(&self, input: InputData) -> Result<OutputData> {
                // 1. Validar input
                input.validate()?;
                
                // 2. Transformar
                let intermediate = self.process(input)?;
                
                // 3. Validar output
                let output = self.finalize(intermediate)?;
                output.validate()?;
                
                Ok(output)
            }
        }
        ```
        
        Explicar cada paso de transformaciÃ³n.
      
    - name: "error_handling"
      title: "âš ï¸ MANEJO DE ERRORES"
      required: true
      prompt: |
        Errores especÃ­ficos de la integraciÃ³n:
        
        ```rust
        #[derive(Debug, thiserror::Error)]
        pub enum IntegrationError {
            #[error("Input validation failed: {0}")]
            InputValidationFailed(String),
            
            #[error("Component A failed: {0}")]
            ComponentAFailed(#[from] ComponentAError),
            
            #[error("Component B failed: {0}")]
            ComponentBFailed(#[from] ComponentBError),
            
            #[error("Transformation failed: {0}")]
            TransformationFailed(String),
        }
        ```
        
        - Estrategias de retry
        - Fallbacks
        - Logging y observabilidad
      
    - name: "state_management"
      title: "ğŸ”„ GESTIÃ“N DE ESTADO"
      required: true
      prompt: |
        Si la integraciÃ³n es stateful:
        
        - Estados posibles
        - Transiciones vÃ¡lidas
        - Persistencia de estado
        - RecuperaciÃ³n ante fallos
        
        ```rust
        pub enum IntegrationState {
            Idle,
            Processing,
            WaitingForResponse,
            Completed,
            Failed,
        }
        ```
      
    - name: "async_sync_patterns"
      title: "â±ï¸ PATRONES ASYNC/SYNC"
      required: true
      prompt: |
        - Â¿Es sÃ­ncrona o asÃ­ncrona la integraciÃ³n?
        - Â¿Usa callbacks, futures, channels?
        - Â¿CÃ³mo se manejan timeouts?
        
        ```rust
        // Ejemplo async
        pub async fn integrate_async(
            &self, 
            input: InputData
        ) -> Result<OutputData> {
            tokio::time::timeout(
                Duration::from_secs(5),
                self.transform(input)
            ).await?
        }
        ```
      
    - name: "performance_optimization"
      title: "âš¡ OPTIMIZACIÃ“N DE PERFORMANCE"
      required: true
      prompt: |
        - Batching de requests
        - Caching de resultados
        - Connection pooling
        - Lazy loading
        
        | OptimizaciÃ³n | Impacto | Implementado |
        |--------------|---------|--------------|
        | Batching     | -50% latency | âœ… |
        | Caching      | -80% DB calls | â¸ï¸ |
      
    - name: "testing_integration"
      title: "ğŸ§ª TESTING DE INTEGRACIÃ“N"
      required: true
      prompt: |
        Tests end-to-end:
        
        ```rust
        #[tokio::test]
        async fn test_component_a_to_b_integration() {
            // Setup
            let integration = IntegrationLayer::new();
            let input = create_test_input();
            
            // Execute
            let output = integration.transform(input).await.unwrap();
            
            // Verify
            assert_eq!(output.expected_field, expected_value);
        }
        ```
        
        - Happy path tests
        - Error path tests
        - Edge cases
        - Load testing
      
    - name: "monitoring_observability"
      title: "ğŸ“Š MONITOREO Y OBSERVABILIDAD"
      required: true
      prompt: |
        MÃ©tricas clave:
        - Latencia de transformaciÃ³n
        - Tasa de errores
        - Throughput (requests/sec)
        - TamaÃ±o de payloads
        
        Logging:
        ```rust
        tracing::info!(
            input_size = input.size(),
            output_size = output.size(),
            duration_ms = elapsed.as_millis(),
            "Integration completed successfully"
        );
        ```
      
    - name: "rollback_strategy"
      title: "ğŸ”™ ESTRATEGIA DE ROLLBACK"
      required: false
      prompt: |
        Si la integraciÃ³n modifica estado:
        - CÃ³mo revertir cambios
        - Compensating transactions
        - Idempotencia
      
    - name: "references"
      title: "ğŸ“š REFERENCIAS"
      required: true
      prompt: |
        - Specs de Component A (02_COMPONENTES/)
        - Specs de Component B (02_COMPONENTES/)
        - Arquitectura relacionada (01_ARQUITECTURA/)
        - Decisiones arquitectÃ³nicas (DA-XXX)
      
    - name: "future_improvements"
      title: "ğŸš€ MEJORAS FUTURAS"
      required: true
      prompt: |
        - v1.0: ImplementaciÃ³n bÃ¡sica
        - v2.0: Optimizaciones (batching, caching)
        - v3.0: DistribuciÃ³n (multi-nodo)

  footer:
    required: true
    format: "markdown"
    content: |
      ---
      **Estado:** [ğŸ“‹ DiseÃ±o | ğŸš§ En desarrollo | âœ… Implementado]  
      **Complejidad:** [ğŸŸ¢ BAJA | ğŸŸ¡ MEDIA | ğŸ”´ ALTA]  
      **Prioridad:** [ğŸ”´ CRÃTICA | ğŸŸ¡ ALTA | ğŸŸ¢ MEDIA]
      
      ---
      *Generado: {fecha}*  
      *Sistema BitÃ¡cora v1.0 - MTT-DSL Template: integration_spec*

# Validaciones
validations:
  - check: "has_data_contracts"
    message: "Debe definir contratos de input/output"
  
  - check: "has_error_handling"
    message: "Debe especificar manejo de errores"
  
  - check: "has_integration_tests"
    message: "Debe incluir ejemplos de tests de integraciÃ³n"

# MÃ©tricas de calidad
quality_metrics:
  min_code_examples: 4
  min_error_types: 3
  min_test_cases: 2
  max_document_size_kb: 20

# Instrucciones para LLMs
llm_instructions: |
  Para documentos de integraciÃ³n:
  
  1. IDENTIFICA componentes del nombre del archivo:
     - "SENSORY_TO_TELESCOPEDB.md" â†’ SensoryEngine + TelescopeDB
     - "CTX7D_TO_VOXELDB.md" â†’ ContextToken7D + VoxelDB
  
  2. LEE specs de ambos componentes:
     - API pÃºblica de Component A
     - API pÃºblica de Component B
     - Formatos de datos de cada uno
  
  3. DISEÃ‘A el contrato de integraciÃ³n:
     - Â¿QuÃ© datos fluyen de A a B?
     - Â¿QuÃ© transformaciones son necesarias?
     - Â¿QuÃ© validaciones debemos hacer?
  
  4. MANEJA errores exhaustivamente:
     - Errores de Component A
     - Errores de transformaciÃ³n
     - Errores de Component B
     - Estrategias de retry/fallback
  
  5. OPTIMIZA el flujo:
     - Â¿Podemos hacer batching?
     - Â¿Vale la pena cachear?
     - Â¿Necesitamos async?
  
  6. PRUEBA end-to-end:
     - Happy path
     - Error paths
     - Edge cases
     - Performance bajo carga

example_output_path: "ROADMAP_V2/03_INTEGRACION/HUBSPOKE_ROUTING.md"

status: "active"
last_updated: "2025-10-26"
usage_count: 0
effectiveness_score: null
